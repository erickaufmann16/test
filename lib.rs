use std::fs;
use std::error::Error;
use std::env;
use regex::Regex;
use std::collections::HashSet;
use std::collections::HashMap;
use std::iter::FromIterator;

///The function executes the two stages of this program: parse the input and resolve the conflicts. Please review the source code of these
///two fuctions for the details.
pub fn run(config: Config) -> Result<(), Box<dyn Error>>{
    let contents = fs::read_to_string(config.filename)?;

    let transactions = parse(&contents);

    match config.option {
        Some(opt) => {
            if opt == "t" {
                print_tran(&transactions); 
            } else if opt == "v" {
                println!("Version: {}",  config.version);
            } else {
                println!("Unknown option: {}",  opt);
            }
        },
        None => resolve(&transactions),
    }
    
    Ok(())
}

//This function prints transactions parsed for review of syntax errors
fn print_tran(tr: &Vec<Transaction>) {
    println!("#############TRANSACTIONS############### \n");
    for i in tr {
        let mode;
        if i.read_only == true {
            mode = "read-only";
        } else {
            mode = "read-write";
        }
        println!("{}: {}\n",  i.name, mode);
        for j in &i.statements {
            println!("{:?}\n",  j);
        }
    }
}

//Data structure representing a transaction
#[derive(Clone, Debug)]
struct Transaction {
    read_only: bool, //Whether the transaction is read-write or read-only
    name: String, //Name of the transaction
    statements: Vec<Statement>, //List of SQL statements in this transaction
}

//Data structure representing a statement inside a transaction
#[derive(Clone, Debug)]
struct Statement {
    kind: String, //Statement type: select, update, insert, delete
    table: String, //Table the statement operates upon
    items_read: Vec<String>, //Items read in this statement
    items_written: Vec<String>, //Items written in this statement
    d_set: Vec<String>, //Decision set of this statement
}

//Data structure representing predicate-based conflicts on a specific decision set
#[derive(Clone, Debug)]
struct ReadWriteTransactionsPred {
    d_set: HashSet<String>, //Decision set the conflicts incident upon
    read_transactions: HashSet<String>, //Transactions performing the predicate read
    write_transactions: HashSet<(String, String)>, //Transactions writing the decision set, with the second field being the type of write: update, insert, delete
}

//Data structure representing item-based conflicts on a specific field
#[derive(Clone, Debug)]
struct ReadWriteTransactionsItem {
    item: String, //Data field the conflicts incident upon
    read_transactions: HashSet<String>, //Transactions performing item read of the field
    write_transactions: HashSet<(String, String)>, //Transactions writing the data field, with the second field being the type of write: update, insert, delete
}

//Data structure representing item-based conflicts per transaction pair
#[derive(Clone, Debug)]
struct ItemConflict {
    item: String,
    comment: String,
    table: String,
}

//Data structure representing predicate-based conflicts per transaction pair
#[derive(Clone, Debug)]
struct PredConflict {
    d_set: HashSet<String>,
    comment: String,
    table: String,
}

//This function takes transactions generated by the parse function and resolve them into RW conflicts, which are printed out as in Example 15
fn resolve(trans: &Vec<Transaction>) {
    let mut items: HashMap<String, Vec<ReadWriteTransactionsItem>> = HashMap::new();  //Item based RW conflicts per table
    let mut predicates: HashMap<String, Vec<ReadWriteTransactionsPred>> = HashMap::new();  //Predicate based RW conflicts per table

    //Process item reads from trans
    for t in trans {
        for s in &t.statements {
            if s.kind == "select" || s.kind == "update" {  
                for i in &s.items_read {
                    let ta = items.entry(s.table.clone()).or_insert(Vec::new());
                    let mut present = false; //Indicates whether item i is already in items
                    let length = ta.len();
                    let mut j = 0;

                    while j < length {
                        if *i == ta[j].item {
                            if !ta[j].read_transactions.contains(&t.name) {
                                ta[j].read_transactions.insert(t.name.clone());
                            }
                            present = true;
                            break;
                        }                       
                        j += 1;                   
                    }
                    if present == false { //Adds a new ReadWriteTransactionsItem to items if i is not in it yet
                        let mut new_read_trans = HashSet::new();

                        new_read_trans.insert(t.name.clone());

                        let new_item = ReadWriteTransactionsItem {
                            item: i.clone(),
                            read_transactions: new_read_trans,
                            write_transactions: HashSet::new(),
                        };

                        ta.push(new_item);
                    }        
                }
            }

            //Process predicate reads from trans
            if !s.d_set.is_empty() {
                let ta = predicates.entry(s.table.clone()).or_insert(Vec::new());
                let d_set_hash: HashSet<String> = HashSet::from_iter(s.d_set.clone());
                let mut present = false; //Indicates whether d_set_hash is already in predicates
                let length = ta.len();
                let mut i = 0;

                while i < length {
                    if d_set_hash.symmetric_difference(&ta[i].d_set).count() == 0 {
                        if !ta[i].read_transactions.contains(&t.name) {
                            ta[i].read_transactions.insert(t.name.clone());
                        }
                        present = true;
                        break;    
                    }
                    i += 1;
                }
                if present == false { //Adds a new ReadWriteTransactionsPred to predicates if d_set_hash is not in it yet
                    let mut new_read_trans = HashSet::new();

                    new_read_trans.insert(t.name.clone());

                    let new_pred = ReadWriteTransactionsPred {
                        d_set: d_set_hash,
                        read_transactions: new_read_trans,
                        write_transactions: HashSet::new(),
                    };

                    ta.push(new_pred);
                }
            }
        }  
    }

    //Process writes from trans

    //For the case a decision set is missing in a statement
    let mut all: HashSet<String> = HashSet::new();      
    all.insert(String::from("all")); 

    for t in trans {
        for s in &t.statements {
            //Dealing with the single write in an update statement for items
            if s.kind == "update" {
                let ta = items.entry(s.table.clone()).or_insert(Vec::new());
                let mut present = false; //Indicates whether the updated item is already in items
                let length = ta.len();
                let mut i = 0;

                while i < length {
                    if s.items_written[0] == ta[i].item {
                        if !ta[i].write_transactions.contains(&(t.name.clone(), String::from("U"))) {
                            ta[i].write_transactions.insert((t.name.clone(), String::from("U")));
                        }
                        present = true;
                        break;
                    }
                    i += 1;
                }
                //Adds a new ReadWriteTransactionsItem to items if i is not in it yet. Notice this part can be eliminated when we only concern about RW conflicts since if an item read
                //is not present, there are no RW conflicts any way. I keep it here in case we have to deal with WW conflict in the future.                
                if present == false {
                    let mut new_write_trans = HashSet::new();

                    new_write_trans.insert((t.name.clone(), String::from("U")));

                    let new_item = ReadWriteTransactionsItem {
                        item: s.items_written[0].clone(),
                        read_transactions: HashSet::new(),
                        write_transactions: new_write_trans,
                    };

                    ta.push(new_item);
                }
                
                //Process the single write in an update for predicates  
                let ta = predicates.entry(s.table.clone()).or_insert(Vec::new());
                let length = ta.len();
                let mut i = 0;

                while i < length {
                   if ta[i].d_set.symmetric_difference(&all).count() == 0 {
                       i += 1;
                       continue;
                   } else if ta[i].d_set.contains(&s.items_written[0]) {
                       if !ta[i].write_transactions.contains(&(t.name.clone(), String::from("U"))) {
                            ta[i].write_transactions.insert((t.name.clone(), String::from("U")));
                        }
                   }
                   i += 1;
                }               
            } else if s.kind == "insert" || s.kind == "delete" {   //Process writes in insert or delete for each item 
                if items.contains_key(&s.table) {
                    let ta = items.entry(s.table.clone()).or_insert(Vec::new());                    
                    let length = ta.len();
                    let mut i = 0;

                    while i < length {
                        if s.kind == "insert" {
                            if !ta[i].write_transactions.contains(&(t.name.clone(), String::from("I"))) {
                                ta[i].write_transactions.insert((t.name.clone(), String::from("I")));
                            }
                        }
                        else if s.kind == "delete" {
                            if !ta[i].write_transactions.contains(&(t.name.clone(), String::from("D"))) {
                                ta[i].write_transactions.insert((t.name.clone(), String::from("D")));
                            }
                        }
                        i += 1; 
                    }
                }

                //Process writes in insert or delete for each predicate
                if predicates.contains_key(&s.table) {
                    let ta = predicates.entry(s.table.clone()).or_insert(Vec::new());
                    let length = ta.len();
                    let mut i = 0;

                    while i < length {
                        if s.kind == "insert" {
                            if !ta[i].write_transactions.contains(&(t.name.clone(), String::from("I"))) {
                                ta[i].write_transactions.insert((t.name.clone(), String::from("I")));
                            }
                        }
                        else if s.kind == "delete" {
                            if !ta[i].write_transactions.contains(&(t.name.clone(), String::from("D"))) {
                                ta[i].write_transactions.insert((t.name.clone(), String::from("D")));
                            }
                        }
                        i += 1; 
                    }
                }
            }
        }
    }
  
    //Start printing the RW conflicts

    //Print the RW conflicts per table as in Example 15
    print_rw(&items, &predicates);

    //Preparing RW conflicts per transaction pair
    let mut item_conflicts: HashMap<(String, String), Vec<ItemConflict>> = HashMap::new(); //Item based RW conflicts per transaction pair
    let mut pred_conflicts: HashMap<(String, String), Vec<PredConflict>> = HashMap::new(); //Predicate based RW conflicts per transaction pair

    //Identify item based conflicts per transaction pair
    for (key,value) in items {
        let mut i = 0;
        let length = value.len();

        while i < length {
            if !value[i].read_transactions.is_empty() && !value[i].write_transactions.is_empty() {
                for r in &value[i].read_transactions {
                    for w in &value[i].write_transactions {
                        let rw = item_conflicts.entry((r.clone(), w.0.clone())).or_insert(Vec::new());
                        let mut j =0;
                        let length = rw.len();
                        let mut present = false;

                        while j < length {
                            if rw[j].item == value[i].item && rw[j].table == key {
                            present = true;
                            break;
                            }
                            j += 1;
                        }
                        //If conflict on a specific field in a specific table is not present yet, adds it to that specific pair of transaction
                        if present == false {
                            let new_item = ItemConflict {
                                item: value[i].item.clone(),
                                comment: String::from("item based"),
                                table: key.clone(),
                            };
                            rw.push(new_item)
                        }
                    }
                }
            }
            i += 1; 
        }
    }

    //Identify predicate based conflicts per transaction pair
    for (key,value) in predicates {
        let mut i = 0;
        let length = value.len();

        while i < length {
            if !value[i].read_transactions.is_empty() && !value[i].write_transactions.is_empty() {
                for r in &value[i].read_transactions {
                    for w in &value[i].write_transactions {
                        let rw = pred_conflicts.entry((r.clone(), w.0.clone())).or_insert(Vec::new());
                        let mut j =0;
                        let length = rw.len();
                        let mut present = false;

                        while j < length {
                            if value[i].d_set.symmetric_difference(&rw[j].d_set).count() == 0 && rw[j].table == key {
                            present = true;
                            break;
                            }
                            j += 1;
                        }
                        //If conflict on a specific decision set in a specific table is not present yet, adds it to that specific pair of transaction
                        if present == false {
                            let new_pred = PredConflict {
                                d_set: value[i].d_set.clone(),
                                comment: String::from("predicate based"),
                                table: key.clone(),
                            };
                            rw.push(new_pred)
                        }
                    }
                }
            }
            i += 1; 
        }
    }

    print_conflict(&item_conflicts, &pred_conflicts);
}

//This function prints the RW conflicts per transaction pair as in Example 15
fn print_conflict(it: &HashMap<(String, String), Vec<ItemConflict>>, pr: &HashMap<(String, String), Vec<PredConflict>>) {
    println!("#############ITEM BASED RW CONFLICTS PER TRANSACTION PAIR############### \n");
    for (key, value) in it {
        println!("{} --> {}\n",  key.0, key.1);
        println!("Item\t\tComment\t\tTable");
        for i in value {           
            println!("{}\t\t{}\t\t{}", i.item, i.comment, i.table);
        }
        println!("\n");  
    }

    println!("#############PREDICATE BASED RW CONFLICTS PER TRANSACTION PAIR############### \n");
    for (key, value) in pr {
        println!("{} --> {}\n",  key.0, key.1);
        println!("D_set\t\tComment\t\tTable");
        for i in value {     
            println!("{:?}\t\t{}\t\t{}", i.d_set, i.comment, i.table);
        }
        println!("\n");  
    }
}

//This function prints the RW conflicts per table as in Example 15
fn print_rw(it: &HashMap<String, Vec<ReadWriteTransactionsItem>>, pr: &HashMap<String, Vec<ReadWriteTransactionsPred>>) {
    println!("#############ITEM BASED RW CONFLICTS BY TABLE############### \n");
    for (key, value) in it {
        let mut i = 0;
        let length = value.len();
        let mut present = false;

        while i < length {
            if !value[i].read_transactions.is_empty() && !value[i].write_transactions.is_empty() {
                present = true;
                break;
            }
            i += 1; 
        }

        //As opposed to Example 15, only RW conflicts are printed
        if present == true {
            println!("Table: {}\n",  key);
            println!("Item\t\tRead\t\tWrite\n");
            i = 0;

            while i < length {
                if !value[i].read_transactions.is_empty() && !value[i].write_transactions.is_empty() {
                    println!("{}\t\t{:?}\t\t{:?}",  value[i].item, value[i].read_transactions, value[i].write_transactions);
                }
                i += 1; 
            }
            println!("\n");
        }
    }  

    println!("#############PREDICATE BASED RW CONFLICTS BY TABLE############### \n");
    for (key, value) in pr {
        let mut i = 0;
        let length = value.len();
        let mut present = false;

        while i < length {
            if !value[i].read_transactions.is_empty() && !value[i].write_transactions.is_empty() {
                present = true;
                break;
            }
            i += 1; 
        }

        //As opposed to Example 15, only RW conflicts are printed
        if present == true {
            println!("Table: {}\n",  key);
            println!("Decision set\t\tRead\t\tWrite\n");
            i = 0;

            while i < length {
                if !value[i].read_transactions.is_empty() && !value[i].write_transactions.is_empty() {
                    println!("{:?}\t\t{:?}\t\t{:?}",  value[i].d_set, value[i].read_transactions, value[i].write_transactions);
                }
                i += 1; 
            }
            println!("\n");
        }
    }  
}

//This function parses an input file into a vector of transactions.
fn parse(contents: &str) -> Vec<Transaction> {
    //The vector of transactions we are going to return
    let mut trans: Vec<Transaction> = Vec::new();

    //Temporary data structure holding the transaction being generated
    let mut current_tran = Transaction {
        read_only: true,
        name: String::from(""),
        statements: Vec::new(),
    };

    //Temporary data structure holding a statement in the transaction being generated
    let mut current_stm = Statement {
        kind: String::from(""),
        table: String::from(""),
        items_read: Vec::new(),
        items_written: Vec::new(),
        d_set: Vec::new(),
    };

    //The following regular expressions are used to parse different statements in a transaction, the ones prepended with 'pre' are for preprocessing
    let pre_start = Regex::new(r"^start transaction").unwrap();
    let start = Regex::new(r"^start transaction[\s]+(?P<tran_name>[_a-z0-9#@$]+)").unwrap();
    let pre_insert = Regex::new(r"^insert[\s]").unwrap();
    let insert = Regex::new(r"^insert[\s]+into[\s]+(?P<table_name>[_a-z0-9#@$]+)").unwrap();
    let pre_select = Regex::new(r"^select[\s]").unwrap();

    //Select with a where clause
    let select1 = Regex::new(r"^select[\s]+(?P<select_items>[[:punct:][:alnum:]\s]+)from[\s]+(?P<table_name>[_a-z0-9#@$]+)[\s]+where[\s]+(?P<where_condition>[[:punct:][:alnum:]\s]+);").unwrap();

    //Select without a where clause
    let select2 = Regex::new(r"^select[\s]+(?P<select_items>[[:punct:][:alnum:]\s]+)from[\s]+(?P<table_name>[_a-z0-9#@$]+)").unwrap();

    let pre_update = Regex::new(r"^update[\s]").unwrap();

    //Update with a where clause
    let update1 = Regex::new(r"^update[\s]+(?P<table_name>[_a-z0-9#@$]+)[\s]+set[\s]+(?P<update_exp>[[:punct:][:alnum:]\s]+)where[\s]+(?P<where_condition>[[:punct:][:alnum:]\s]+);").unwrap();

    //Update without a where clause
    let update2 = Regex::new(r"^update[\s]+(?P<table_name>[_a-z0-9#@$]+)[\s]+set[\s]+(?P<update_exp>[[:punct:][:alnum:]\s]+)").unwrap();

    let pre_delete = Regex::new(r"^delete[\s]").unwrap();

    //Delete with a where clause
    let delete1 = Regex::new(r"^delete from (?P<table_name>[_a-z0-9#@$]+)[\s]+where[\s]+(?P<where_condition>[[:punct:][:alnum:]\s]+);").unwrap();

    //Delete without a where clause
    let delete2 = Regex::new(r"^delete from (?P<table_name>[_a-z0-9#@$]+)").unwrap();

    let commit = Regex::new(r"^commit").unwrap();

    //For supplied decision set of a statement
    let d_set = Regex::new(r"^d_set:(?P<list>[,_a-z0-9#@$\s]+)").unwrap();

    //For supplied select set of a statement
    let select_set = Regex::new(r"^select_set:(?P<list>[,_a-z0-9#@$\s]*)").unwrap();

    let mut d_set_flag = false;
    let mut d_set_list: Vec<String> = Vec::new();
    let mut select_set_flag = false;
    let mut select_set_list: Vec<String> = Vec::new();

    for line in contents.lines() {
        let line = line.to_lowercase();
        let line = line.trim();

        //Parse a supplied select set
        if select_set.is_match(line) {
            select_set_flag = true;
            let caps = select_set.captures(line).unwrap();
            select_set_list = parse_comma_separated_list(caps.name("list").unwrap().as_str(), line);
            //println!("{:?}",  select_set_list);
        }
        //Parse a supplied decision set
        if d_set.is_match(line) {
            d_set_flag = true;
            let caps = d_set.captures(line).unwrap();
            d_set_list = parse_comma_separated_list(caps.name("list").unwrap().as_str(), line);         
            //println!("{:?}",  d_set_list);
        }
        //Parse a start statement
        if pre_start.is_match(line) {
            if start.is_match(line) {
                let caps = start.captures(line).unwrap();
                current_tran.name = caps.name("tran_name").unwrap().as_str().to_string();
                current_tran.read_only = true;
                current_tran.statements = Vec::new();
                //println!("{} {}", "start", current_tran.name);
            }
            else {
                panic!("Transaction name syntax error in line: {}", line);
            }
        }
        //Parse an insert statement
        if pre_insert.is_match(line) {
            if insert.is_match(line) {
                let caps = insert.captures(line).unwrap();
                current_stm.kind = String::from("insert");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_read = Vec::new();
                current_stm.items_written = Vec::new(); 
                current_stm.d_set = Vec::new();
                if current_tran.read_only == true {
                    current_tran.read_only = false;
                }
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone());
            }
         else {
                panic!("Syntax error in line: {}", line);
            }
        }
        //Parse a select statement
        if pre_select.is_match(line) {
            if select1.is_match(line) {
                let caps = select1.captures(line).unwrap();
                current_stm.kind = String::from("select");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_written = Vec::new();          
                if select_set_flag == true {
                    current_stm.items_read = select_set_list.clone();
                    select_set_flag = false;
                } else {
                     current_stm.items_read = parse_comma_separated_list(caps.name("select_items").unwrap().as_str(), line);
                }
                if d_set_flag == true {
                    current_stm.d_set = d_set_list.clone();
                    d_set_flag = false;
                } else {
                    current_stm.d_set = parse_where_condition(caps.name("where_condition").unwrap().as_str(), line);
                }
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone());
            } else if select2.is_match(line) {
                let caps = select2.captures(line).unwrap();
                current_stm.kind = String::from("select");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_written = Vec::new();
                current_stm.d_set = Vec::new();          
                if select_set_flag == true {
                    current_stm.items_read = select_set_list.clone();
                    select_set_flag = false;
                } else {
                     current_stm.items_read = parse_comma_separated_list(caps.name("select_items").unwrap().as_str(), line);
                }
                current_stm.d_set.push(String::from("all"));
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone());
            }
            else {
                panic!("Syntax error in line: {}", line);
            }
        }
        //Parse an update statement
        if pre_update.is_match(line) {
            if update1.is_match(line) {
                let caps = update1.captures(line).unwrap();
                current_stm.kind = String::from("update");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_written = Vec::new();
                current_stm.items_read = Vec::new();
                let (write, read) = parse_update_exp(caps.name("update_exp").unwrap().as_str(), line);
                current_stm.items_written.push(write.clone());
                if read != "" && read == write {
                    current_stm.items_read.push(read);
                }
                if d_set_flag == true {
                    current_stm.d_set = d_set_list.clone();
                    d_set_flag = false;
                } else {
                    current_stm.d_set = parse_where_condition(caps.name("where_condition").unwrap().as_str(), line);
                }
                if current_tran.read_only == true {
                    current_tran.read_only = false;
                }
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone());    
            } else if update2.is_match(line) {
                let caps = update2.captures(line).unwrap();
                current_stm.kind = String::from("update");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_written = Vec::new();
                current_stm.items_read = Vec::new();
                current_stm.d_set = Vec::new();
                let (write, read) = parse_update_exp(caps.name("update_exp").unwrap().as_str(), line);
                current_stm.items_written.push(write.clone());
                if read != "" && read == write {
                    current_stm.items_read.push(read);
                }
                current_stm.d_set.push(String::from("all"));
                if current_tran.read_only == true {
                    current_tran.read_only = false;
                }
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone());    
            }
            else {
                panic!("Syntax error in line: {}", line);
            }
        }
        //Parse a delete statement
        if pre_delete.is_match(line) {
            if delete1.is_match(line) {
                let caps = delete1.captures(line).unwrap();
                current_stm.kind = String::from("delete");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_read = Vec::new();
                current_stm.items_written = Vec::new();
                if d_set_flag == true {
                    current_stm.d_set = d_set_list.clone();
                    d_set_flag = false;
                } else {
                    current_stm.d_set = parse_where_condition(caps.name("where_condition").unwrap().as_str(), line);
                }
                if current_tran.read_only == true {
                    current_tran.read_only = false;
                }
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone()); 
            } else if delete2.is_match(line) {
                let caps = delete2.captures(line).unwrap();
                current_stm.kind = String::from("delete");
                current_stm.table = caps.name("table_name").unwrap().as_str().to_string();
                current_stm.items_read = Vec::new();
                current_stm.items_written = Vec::new();
                current_stm.d_set = Vec::new();
                current_stm.d_set.push(String::from("all"));
                if current_tran.read_only == true {
                    current_tran.read_only = false;
                }
                //println!("{:?}",  current_stm);
                current_tran.statements.push(current_stm.clone()); 
            }
            else {
                panic!("Syntax error in line: {}", line);
            }
        }
        //Parse a commit statement
        if commit.is_match(line) {
            trans.push(current_tran.clone());
            //println!("{}", "commit");
        }      
    }

    trans
}

//This function parses the where condition for the decision set, where the passed-in 'input' variable is the part of a statement after the 'where' key word
fn parse_where_condition(input: &str, line: &str) -> Vec<String> {
    let mut tokens = Vec::new();
    let input = input.trim();
    let mut predicate;

    //Drop everything after the where condition and place it in variable 'predicate'
    let where_con = Regex::new(r"^(?P<pred>[[:punct:][:alnum:]\s]+)(group|having|window|order|limit|for|lock|into)").unwrap();

    if where_con.is_match(input) {
        let caps = where_con.captures(input).unwrap();
        predicate = caps.name("pred").unwrap().as_str();
    } else {
        predicate = input;
    }

    predicate = predicate.trim();
    
    //For a column in a clause of the where condition
    let token = Regex::new(r"^(?P<column>[_a-z0-9#@$]+)[\s]*(=|>|<|>=|<=|<>|between|like|in)").unwrap();

    //The part before the last clause
    let clause_plus = Regex::new(r"^(?P<clau>[[:punct:][:alnum:]\s]+)(xor|\|\||and|&&|\bor)").unwrap();

    //Separators between clauses
    let separator = Regex::new(r"^(?P<sepa>(\bor|\|\||and|&&|xor)[\s]+)").unwrap();

    //Process 'predicate' backwards
    let mut start = predicate.len();
    let mut end = predicate.len();
    let mut slice = &predicate[..end];
    
    //Break the where condition in 'predicate' into clauses 
    while start != 0 {
        let mut clause;

        //When the where condition consists of more than one clause
        if clause_plus.is_match(slice) {
            let caps = clause_plus.captures(slice).unwrap();
            start = caps.name("clau").unwrap().as_str().len();
            //Last clause and the separator before it
            let inter_clause = &predicate[start..end];

            //Parse separator between clauses
            if separator.is_match(inter_clause) {
                let caps = separator.captures(inter_clause).unwrap();
                let clause_start = start + caps.name("sepa").unwrap().as_str().len();
                clause = &predicate[clause_start..end];
                end = start;
                slice = &predicate[..end];
            } else {
                panic!("Separator syntax error in line: {}", line);
            }
        } else {  //When the where condition consists of exactly one clause
            clause = slice;
            start = 0;
        }

        //Process a clause in the where condition
        clause = clause.trim();

        if token.is_match(clause) {
            let caps = token.captures(clause).unwrap();

            //Filter out redundant columns
            let col = caps.name("column").unwrap().as_str().to_string(); 
            let mut count = 0;
            for i in tokens.clone() {
                if i == col {
                    break;
                } else {
                    count += 1;
                }
            }
            if count == tokens.len() { 
                tokens.push(col);
            }   
        }  else {
                panic!("Where condition column or separator syntax error in line: {}", line);
        }       
    }
    
    tokens.reverse();
    //println!("{:?}", tokens);

    tokens
}

//This function parses a list as in 'select_set' or 'd_set' and rerurns the columns in it
fn parse_comma_separated_list(input: &str, line: &str) -> Vec<String> {
    let mut tokens = Vec::new();
    let input = input.trim();
    let token = Regex::new(r"^(?P<select_item>[_a-z0-9#@$]+)").unwrap();
    let separator = Regex::new(r"^(?P<sepa>[\s]*,[\s]*)").unwrap();

    let mut start = 0;
    let length = input.len();
    if length > 0 {
        let mut slice = &input[start..];

        //Parse first item in the list
        if token.is_match(slice) {
            let caps = token.captures(slice).unwrap();
            start += caps.name("select_item").unwrap().as_str().len();
            tokens.push(caps.name("select_item").unwrap().as_str().to_string());
        } else {
            panic!("Selected field syntax error in line: {}", line);
        }

        while start != length {
            //Parse separator
            slice = &input[start..];
            if separator.is_match(slice) {
            let caps = separator.captures(slice).unwrap();
            start += caps.name("sepa").unwrap().as_str().len();
            } else {
                panic!("Selected field or separator syntax error in line: {}", line);
            }
            //Parse rest of the list
            slice = &input[start..];
            if token.is_match(slice) {
                let caps = token.captures(slice).unwrap();
                start += caps.name("select_item").unwrap().as_str().len();

                //Filter out redundant items
                let col = caps.name("select_item").unwrap().as_str().to_string(); 
                let mut count = 0;
                for i in tokens.clone() {
                    if i == col {
                        break;
                    } else {
                        count += 1;
                    }
                }
                if count == tokens.len() { 
                    tokens.push(col);
                }
            } else {
                panic!("Selected field syntax error in line: {}", line);
            }
        }
    }   
    //println!("{:?}",  tokens);
    
    tokens
}

//This function parses an update expression and return the items read and written
fn parse_update_exp(input: &str, line: &str) -> (String, String) {
    let mut item_read = String::from("");
    let item_written;
    let input = input.trim();
    let token = Regex::new(r"^(?P<update_item>[_a-z0-9#@$]+)").unwrap();
    let separator = Regex::new(r"^(?P<sepa>[\s]*=[\s]*)").unwrap();

    let mut start = 0;
    let mut slice = &input[start..];

    //Parse updated field
    if token.is_match(slice) {
        let caps = token.captures(slice).unwrap();
        start += caps.name("update_item").unwrap().as_str().len();
        item_written = caps.name("update_item").unwrap().as_str().to_string();
    } else {
        panic!("Updated field syntax error in line: {}", line);
    }

    //Parse assignment operator
    slice = &input[start..];
    if separator.is_match(slice) {
        let caps = separator.captures(slice).unwrap();
        start += caps.name("sepa").unwrap().as_str().len();
    } else {
        panic!("Assignment operator syntax error in line: {}", line);
    }

    //Parse it if updated field is read
    slice = &input[start..];
    if token.is_match(slice) {
        let caps = token.captures(slice).unwrap();
        item_read = caps.name("update_item").unwrap().as_str().to_string();
    }

    (item_written, item_read)
}

///Configuration information per run.
pub struct Config {
    pub filename: String,
    pub option: Option<String>,
    pub version: String,
}

impl Config {
    pub fn new(mut args: env::Args) -> Result<Config, &'static str> {
        let version = String::from("0.1.0");
        let mut option: Option<String> = None;
        let filename;

        args.next();

        let first = match args.next() {
            Some(arg) => arg,
            None => return Err("There should be at least one argument"),
        };

        match args.next() {
            Some(arg) => {
                option = Some(first);
                filename = arg;
            },
            _ =>  filename = first,
        }

        Ok(Config {filename, option, version})
    }
}